part of '{{ fileName }}';

// Generated extension for {{ className }}
extension {{ className }}Cypher on {{ className }} {
  /// Returns a map of parameter names to values for Cypher queries.
  Map<String, dynamic> get cypherParameters {
    return {
      {% for field in fields %}
      {% if not field['isIgnored'] %}
      '{{ field['cypherName'] }}': {{ field['name'] }},
      {% endif %}
      {% endfor %}
    };
  }

  /// Returns Cypher node properties syntax string with parameter placeholders.
  String get cypherProperties {
    final props = <String>[];
    {% for field in fields %}
    {% if not field['isIgnored'] %}
    props.add('{{ field['cypherName'] }}: \${{ field['cypherName'] }}');
    {% endif %}
    {% endfor %}
    return '{${props.join(', ')}}';
  }

  /// Returns complete Cypher node syntax with variable name, label, and properties.
  /// Example: `user.toCypherWithPlaceholders('u')` returns `'(u:User {id: $id, name: $name})'`
  String toCypherWithPlaceholders(String variableName) {
    return '($variableName:${{ '{' }}nodeLabel{{ '}' }} $cypherProperties)';
  }

  /// The Neo4j node label for this {{ className }}.
  static const String nodeLabel = '{{ label }}';

  /// Record of property names used in Cypher queries.
  /// Each field name corresponds to the Dart property name, with the Cypher property name as its value.
  static const ({{ '{' }}{% for field in fields %}{% if not field['isIgnored'] %}String {{ field['name'] }}, {% endif %}{% endfor %}{{ '}' }}) cypherPropertyNames = (
    {% for field in fields %}
    {% if not field['isIgnored'] %}
    {{ field['name'] }}: '{{ field['cypherName'] }}',
    {% endif %}
    {% endfor %}
  );

  /// Returns Cypher node properties syntax string with prefixed parameter placeholders.
  /// This helps avoid parameter name collisions in complex queries.
  /// Example: `user.cypherPropertiesWithPrefix('user_')` returns `'{id: $user_id, name: $user_name}'`
  String cypherPropertiesWithPrefix(String prefix) {
    final props = <String>[];
    {% for field in fields %}
    {% if not field.isIgnored %}
    props.add('{{ field.cypherName }}: \$${prefix}{{ field.cypherName }}');
    {% endif %}
    {% endfor %}
    return '{${props.join(', ')}}';
  }

  /// Returns a map of parameter names to values with the specified prefix.
  /// This helps avoid parameter name collisions in complex queries.
  /// Example: `user.cypherParametersWithPrefix('user_')` returns `{'user_id': '123', 'user_name': 'John'}`
  Map<String, dynamic> cypherParametersWithPrefix(String prefix) {
    return {
      {% for field in fields %}
      {% if not field['isIgnored'] %}
      '${prefix}{{ field['cypherName'] }}': {{ field['name'] }},
      {% endif %}
      {% endfor %}
    };
  }

  /// Returns complete Cypher node syntax with variable name, label, and prefixed properties.
  /// This helps avoid parameter name collisions in complex queries.
  /// Example: `user.toCypherWithPlaceholdersWithPrefix('u', 'user_')` returns `'(u:User {id: $user_id, name: $user_name})'`
  String toCypherWithPlaceholdersWithPrefix(String variableName, String prefix) {
    return '($variableName:${{ '{' }}nodeLabel{{ '}' }} ${cypherPropertiesWithPrefix(prefix)})';
  }
}

{% if includeFromNode %}
/// Private function to create {{ className }} from Neo4j Node object.
/// Use this in a factory constructor like: 
/// `factory {{ className }}.fromNode(Node node) => _${{ className }}FromNode(node);`
{{ className }} _${{ className }}FromNode(Node node) {
  final props = node.properties;

  return {{ className }}(
    {% for field in fields %}
    {% if field['isCypherIdField'] %}
    {{ field['name'] }}: CypherId.value(node.id),
    {% elif field['isCypherElementIdField'] %}
    {{ field['name'] }}: CypherElementId.value(node.elementIdOrThrow),
    {% elif not field['isIgnored'] %}
    {{ field['name'] }}: props['{{ field['cypherName'] }}'] as {{ field['type'] }},
    {% endif %}
    {% endfor %}
  );
}
{% endif %}
